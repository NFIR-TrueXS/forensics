#!/usr/bin/env python3

'''
This file collects and parses files generated by getInstalledSoftware.ps1 and getInstalledUpdates.ps1

Usage:
./parseInstalledSoftwareAndUpdates.py -i <INPUT FOLDER>

The output is JSON
'''

import argparse
import os
import re
import sys

class ParseInstalledSoftwareAndUpdates:
    def __init__(self, inputFolder):
        if os.path.isdir(inputFolder) is False:
            sys.exit('Input folder {} does not exist, exiting'.format(inputFolder))

        self.inputFolder = inputFolder

        # Arrays to hold the collected files
        self.installedFiles = []
        self.updateFiles = []

        # Arrays to hold parsed results
        self.installedSoftware = {}

        # Collect all the files
        self.collectFiles()

        # Parse all installedSoftware.txt files
        self.parseInstalledFiles()
        # Parse all installedUpdates.txt
        self.parseInstalledUpdates()

        print(self.installedSoftware)

    def collectFiles(self):
        for root, subdirs, files in os.walk(self.inputFolder):
            for filename in files:
                if filename == 'installedSoftware.txt':
                    self.installedFiles.append(os.path.join(root, filename))
                elif filename == 'installedUpdates.txt':
                    self.updateFiles.append(os.path.join(root, filename))

    def parseInstalledFiles(self):
        for file in self.installedFiles:
            fr = open(file, 'r')

            machineObj = {}

            # Get file generic information (the first 6 lines in the file)
            generalInfo = {}
            for i in range(0, 6):
                key, value = fr.readline().split(':', 1)
                generalInfo[key.strip()] = value.strip()

            machineObj['softwareInfo'] = generalInfo
            machineObj['software'] = []

            softwareObj = {}
            for line in fr.readlines():
                # Skip whitelines
                if line.strip() == '':
                    # Push gathered software info to machineObject
                    # Whitelines separate different entries,
                    # so we can use them to determine when an object is complete
                    if len(softwareObj) > 0:
                        machineObj['software'].append(softwareObj)
                        softwareObj = {}
                    continue

                # Skip UninstallKey entries
                if line.find('UninstallKey') == 0:
                    continue

                # Skip lines not starting with an uppercase letter
                r = re.compile('^[A-Z]')
                if r.match(line) == None:
                    continue

                key, value = line.strip().split(':', 1)
                softwareObj[key.strip()] = value.strip()

            if generalInfo['Computer name'] not in self.installedSoftware:
                self.installedSoftware[generalInfo['Computer name']] = {}

            self.installedSoftware[generalInfo['Computer name']]['softwareInfo'] = machineObj['softwareInfo']
            self.installedSoftware[generalInfo['Computer name']]['software'] = machineObj['software']

            fr.close()

    def parseInstalledUpdates(self):
        for file in self.updateFiles:
            fr = open(file, 'r')

            machineObj = {}

            # Get file generic information
            generalInfo = {}
            for i in range(0, 6):
                key, value = fr.readline().split(':', 1)
                generalInfo[key.strip()] = value.strip()

            machineObj['updatesInfo'] = generalInfo
            machineObj['updates'] = []

            updatesObj = {}
            for line in fr.readlines():
                # Skip whitelines
                if line.strip() == '':
                    # Push gathered update info to machineObject
                    if len(updatesObj) > 0:
                        machineObj['updates'].append(updatesObj)
                        updatesObj = {}
                    continue

                # Skip lines not starting with an uppercase letter
                # Uninstall-strings can be multiline, but they aren't relevant to our parser.
                # So when a line starts with a lowercase character,
                # it's the second part of a multiline uninstall-string so we can skip it
                r = re.compile('^[A-Z]')
                if r.match(line) == None:
                    continue

                key, value = line.strip().split(':', 1)
                updatesObj[key.strip()] = value.strip()

            if generalInfo['Computer name'] not in self.installedSoftware:
                self.installedSoftware[generalInfo['Computer name']] = {}

            self.installedSoftware[generalInfo['Computer name']]['updatesInfo'] = machineObj['updatesInfo']
            self.installedSoftware[generalInfo['Computer name']]['updates'] = machineObj['updates']

            fr.close()


if __name__ == '__main__':
    ap = argparse.ArgumentParser()
    ap.add_argument('-i', '--input', required=True, help='Input folder')

    args = vars(ap.parse_args())

    ParseInstalledSoftwareAndUpdates(args['input'])
